{
  "series": [
    {
      "color": "#662673",
      "index": 9,
      "legendIndex": 0,
      "data": [
        [
          "2016",
          494
        ],
        [
          "2017",
          517
        ],
        [
          "2018",
          483
        ]
      ],
      "name": "Ehepaare mit Kindern",
      "turboThreshold": 0
    },
    {
      "color": "#B375AB",
      "index": 8,
      "legendIndex": 1,
      "data": [
        [
          "2016",
          199
        ],
        [
          "2017",
          226
        ],
        [
          "2018",
          202
        ]
      ],
      "name": "Ehepaare ohne Kinder",
      "turboThreshold": 0
    },
    {
      "color": "#FFBB58",
      "index": 7,
      "legendIndex": 2,
      "data": [
        [
          "2016",
          965
        ],
        [
          "2017",
          987
        ],
        [
          "2018",
          951
        ]
      ],
      "name": "Einelternfamilie",
      "turboThreshold": 0
    },
    {
      "color": "#A8C3CA",
      "index": 6,
      "legendIndex": 3,
      "data": [
        [
          "2016",
          4132
        ],
        [
          "2017",
          4074
        ],
        [
          "2018",
          3974
        ]
      ],
      "name": "Einzelperson",
      "turboThreshold": 0
    },
    {
      "color": "#8A8A8A",
      "index": 10,
      "legendIndex": 0,
      "data": [
        [
          "2016",
          1
        ],
        [
          "2017",
          0
        ],
        [
          "2018",
          1
        ]
      ],
      "name": "Übrige und kein Eintrag",
      "turboThreshold": 0
    },
    {
      "name": "Rhein",
      "animation": true,
      "data": [
        {
          "path": [
            "M",
            2611898.998,
            -1267399.905,
            "L",
            2612058.909,
            -1267359.334,
            2612200.486,
            -1267350.569,
            2612500.488,
            -1267380.57,
            2613176.587,
            -1267575.834,
            2613700.553,
            -1267750.607,
            2614300.587,
            -1268000.61,
            2614621.94156826,
            -1267973.86403593,
            2614599.062,
            -1267884.68,
            2614419.203,
            -1267906.424,
            2614205.191,
            -1267884.815,
            2613847.869,
            -1267738.097,
            2613472.536,
            -1267564.181,
            2613486.513,
            -1267447.856,
            2613450.527,
            -1267475.587,
            2613300.525,
            -1267450.582,
            2613097.525,
            -1267354.57,
            2613004.724,
            -1267333.97,
            2612868.919,
            -1267274.568,
            2612635.509,
            -1267211.568,
            2612444.672,
            -1267193.259,
            2612097.026,
            -1267173.089,
            2611933.01,
            -1267196.092,
            2611810.036,
            -1267238.412,
            2611784.18,
            -1267253.643,
            2611771.149,
            -1267239.611,
            2611740.489,
            -1267260.564,
            2611660.402,
            -1267321.312,
            2611620.316,
            -1267381.453,
            2611544.897,
            -1267414.515,
            2611405,
            -1267531.369,
            2611260.482,
            -1267720.57,
            2611142.399,
            -1267907.457,
            2610956.49,
            -1268231.564,
            2610964.344,
            -1268244.488,
            2610947.42,
            -1268296.742,
            2610934.264,
            -1268292.513,
            2610894.264,
            -1268510.962,
            2610889.241,
            -1268730.166,
            2610920.508,
            -1269114.948,
            2610875.30000368,
            -1269467.46893253,
            2610988.015,
            -1269434.556,
            2610967.612,
            -1269774.822,
            2610992.904,
            -1270027.827,
            2611066.413,
            -1270387.488,
            2611159.552,
            -1270661.324,
            2611314.911,
            -1271034.144,
            2611625.494,
            -1270932.22,
            2611417.793,
            -1271000.381,
            2611288.913,
            -1270732.042,
            2611172.704,
            -1270396.667,
            2611163.458,
            -1270236.848,
            2611122.804,
            -1270132.43,
            2611082.267,
            -1269843.15,
            2611086.492,
            -1269500.56,
            2611130.99,
            -1269110.558,
            2611121.964,
            -1268903.083,
            2611100.494,
            -1268740.563,
            2611110.744,
            -1268512.065,
            2611178.492,
            -1268240.565,
            2611265.963,
            -1268047.568,
            2611500.485,
            -1267693.56,
            2611740.484,
            -1267487.561,
            2611898.998,
            -1267399.905,
            "Z"
          ],
          "properties": {
            "OBJECTID_1": 22,
            "OBJID": null,
            "OBJECTID": 0,
            "TXT": "0",
            "ZTXT": null,
            "TYPE": null,
            "ZAHL": 0,
            "Shape_Leng": 14839.0255242,
            "Shape_Le_1": 14778.1650629,
            "Shape_Area": 1109076.31304
          }
        }
      ],
      "color": "#008AC3",
      "borderColor": "#fbfbfb",
      "tooltip": {
        "pointFormatter": function () {
						return '<br/>';
					}
      }
    },
    {
      "name": "Massstab",
      "animation": true,
      "type": "mapline",
      "data": [
        {
          "path": [
            "M",
            2609400,
            -1264800,
            "L",
            2609400,
            -1264600,
            2609400,
            -1264700,
            2610400,
            -1264700,
            2610400,
            -1264800,
            2610400,
            -1264600
          ],
          "properties": {
            "OBJECTID_1": 99,
            "OBJID": 99,
            "OBJECTID": 99,
            "TXT": "99",
            "ZTXT": null,
            "TYPE": null,
            "ZAHL": 0,
            "Shape_Leng": 0,
            "Shape_Le_1": 0,
            "Shape_Area": 0
          }
        }
      ],
      "color": "black",
      "tooltip": {
        "pointFormatter": function () {
						return '<br/>';
					}
      },
      "dataLabels": {
        "enabled": true,
        "formatter": function () {
						return '1 km';
					},
        "style": {
          "fontSize": "15px",
          "fontWeight": "normal",
          "color": "black"
        },
        "y": -10
      }
    }
  ],
  "xAxis": {
    "type": "category",
    "uniqueNames": false
  },
  "chart": {
    "borderColor": "#fbfbfb",
    "backgroundColor": "#fbfbfb",
    "width": 992,
    "height": 497,
    "spacing": [
      2,
      2,
      2,
      2
    ],
    "style": {
      "fontFamily": "Arial"
    },
    "type": "column",
    "renderTo": "container-8513",
    "spacingBottom": 12
  },
  "title": {
    "style": {
      "fontSize": "15px",
      "fontWeight": "bold",
      "fontFamily": "Arial",
      "color": "#000000"
    },
    "align": "left",
    "text": "Sozialhilfefälle nach Fallstruktur"
  },
  "subtitle": {
    "style": {
      "fontSize": "15px",
      "fontWeight": "normal",
      "fontFamily": "Arial",
      "color": "#000000"
    },
    "text": "Kanton Basel-Stadt",
    "align": "left"
  },
  "credits": {
    "enabled": true,
    "style": {
      "color": "#000000",
      "fontSize": "15px",
      "cursor": "default"
    },
    "position": {
      "align": "left",
      "verticalAlign": "bottom",
      "x": 10,
      "y": -25
    },
    "text": "Quelle: Statistisches Amt Basel-Stadt, Sozialhilfestatistik.\u003Cbr\u002F\u003EZuletzt geändert: 2019-11-25"
  },
  "colorAxis": {
    "min": 0,
    "gridLineColor": "#fbfbfb",
    "gridLineWidth": 1,
    "labels": {
      "style": {
        "color": "black",
        "cursor": "default",
        "fontSize": "15px",
        "textOverflow": "none"
      }
    },
    "marker": {
      "color": "black"
    }
  },
  "mapNavigation": {
    "enabled": true,
    "buttonOptions": {
      "align": "left",
      "verticalAlign": "bottom"
    }
  },
  "legend": {
    "enabled": true,
    "align": "right",
    "floating": true,
    "symbolPadding": 10,
    "itemStyle": {
      "fontSize": "15px",
      "fontWeight": "normal"
    },
    "title": {
      "style": {
        "fontWeight": "bold",
        "fontSize": "15px"
      }
    },
    "layout": "vertical",
    "verticalAlign": "middle",
    "itemMarginBottom": 5
  },
  "exporting": {
    "allowHTML": true,
    "chartOptions": {
      "plotOptions": {
        "series": {
          "animation": false
        }
      }
    },
    "filename": 8513
  },
  "customFunctions": {
    "pieSizeCategorical": function (value, conf) {
				for (var i = 0; i < conf.length; i++) {
					//console.log('checking value ' + value);
					if (value >= conf[i].from && value < conf[i].to) {
						//console.log('found conf object:  + ' + JSON.stringify(conf[i]));
						return conf[i];
					}
				}
			},
    "pieSize": function (value, maxAbsValue, maxPieDiameter) {

				function circleAreaByDiameter(diameter) {
					return Math.PI * diameter * diameter / 4;
				}

				function circleDiameterByAre(area) {
					return Math.sqrt(4 * area / Math.PI);
				}

            	/*
                var yAxis = chart.yAxis[0],
                    zoomFactor = (yAxis.dataMax - yAxis.dataMin) / (yAxis.max - yAxis.min);
                */

				//Negative values: return absolute value
				//size by Area: use sqrt of value to define size
				//var size = pieSizeMin + chart.chartWidth / 11 * pieSizeFactor *  Math.sqrt(Math.abs(value)) / maxAbsNumber; 

				//transform value to a number between 0 and 1 representing its relation to the min and max values
				//var relativeValue = (Math.abs(value) - minAbsValue) / (maxAbsValue - minAbsValue);

				//transform value to a number between 0 and 1, where value 0 is represented by 0 and maxAbsValue by 1
				var relativeValue = Math.abs(value) / maxAbsValue;
				//console.log('absVal rel: '+ Math.abs(value) + ' ' + relativeValue);
				//infer the pie size 
				var maxPieArea = circleAreaByDiameter(maxPieDiameter);
				var area = relativeValue * maxPieArea;

				//var minPieArea = circleAreaByDiameter(minPieDiameter);
				//var area = relativeValue * (maxPieArea - minPieArea) + minPieArea;

				var diameter = circleDiameterByAre(area);
				//console.log('value absValue area diameter: ' + value + ' ' + Math.abs(value) + ' ' + area + ' ' + diameter);
				return diameter;
			},
    "defineTemplate": function () {

				//define new chart type
				// source: https://www.highcharts.com/blog/data-journalism/effectively-visualizing-us-election-results/, 
				//  which displays  http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/maps/demo/map-pies/


				// New map-pie series type that also allows lat/lon as center option.
				// Also adds a sizeFormatter option to the series, to allow dynamic sizing
				// of the pies.
				Highcharts.seriesType('mappie', 'pie', {
					center: null, // Can't be array by default anymore
					clip: true, // For map navigation
					states: {
						hover: {
							halo: {
								size: 5
							}
						}
					},
					dataLabels: {
						enabled: false
					}

				}, {
						getCenter: function () {
							var options = this.options,
								chart = this.chart,
								slicingRoom = 2 * (options.slicedOffset || 0);
							if (!options.center) {
								options.center = [null, null]; // Do the default here instead
							}
							// Handle lat/lon support
							if (options.center.lat !== undefined) {
								var point = chart.fromLatLonToPoint(options.center);
								options.center = [
									chart.xAxis[0].toPixels(point.x, true),
									chart.yAxis[0].toPixels(point.y, true)
								];
							}
							// Handle dynamic size
							if (options.sizeFormatter) {
								options.size = options.sizeFormatter.call(this);
							}
							// Call parent function
							var result = Highcharts.seriesTypes.pie.prototype.getCenter.call(this);
							// Must correct for slicing room to get exact pixel pos
							result[0] -= slicingRoom;
							result[1] -= slicingRoom;
							return result;
						},
						translate: function (p) {
							this.options.center = this.userOptions.center;
							this.center = this.getCenter();
							return Highcharts.seriesTypes.pie.prototype.translate.call(this, p);
						}
					});

			},
    "getPointsExtremes": function (points) {
				var maxNumber = Number.NEGATIVE_INFINITY;
				var maxAbsNumber = Number.NEGATIVE_INFINITY;
				var minNumber = Number.POSITIVE_INFINITY;
				var minAbsNumber = Number.POSITIVE_INFINITY;
				Highcharts.each(points, function (point) {
					maxNumber = Math.max(maxNumber, point.value);
					maxAbsNumber = Math.max(maxAbsNumber, Math.abs(point.value));
					minNumber = Math.min(minNumber, point.value);
					minAbsNumber = Math.min(minAbsNumber, Math.abs(point.value));
				});
				return {
					maxNumber: maxNumber,
					maxAbsNumber: maxAbsNumber,
					minNumber: minNumber,
					minAbsNumber: minAbsNumber
				};
			},
    "drawPies": function (chart, pieSizeSeries, choroplethSeries, pieSeriesConfig, pieSizeCatConfig, color) {

				//iterate over each wohnviertel and draw the pies / bubbles
				Highcharts.each(pieSizeSeries.points, function (data) {

					if (!data.value) {
						return; // Skip points with no data, if any
					}

					var correspondingMapSeriesItem = choroplethSeries.points[data.index];

					//define where to place the pies on the map
					var pieOffset = correspondingMapSeriesItem.pieOffset || {},
						centerLat = parseFloat(correspondingMapSeriesItem.properties.lat),
						centerLon = parseFloat(correspondingMapSeriesItem.properties.lon);

					//create the highcharts pie chart config
					var currentPieSeries = function (config) {
						//define default properties
						var mapPieConfig = {
							type: 'mappie',
							name: 'pie-' + data.series.name,
							wohnviertel_Name: data["hc-key"],
							wohnviertel_Id: correspondingMapSeriesItem.wohnviertel_Id,
							zIndex: 6, // Keep pies above connector lines
							borderWidth: 1,
							tooltip: {
								headerFormat: '<span style="color:{point.color}">\u25CF</span> <span style="font-size: 15px"> {series.name} </span><br/>',
								pointFormatter: function () {
									return correspondingMapSeriesItem.properties.LIBGEO + ': <b>' + Highcharts.numberFormat((this.v), 3) + '</b><br/>';
								}
							},
							center: {
								lat: centerLat + (pieOffset.lat || 0),
								lon: centerLon + (pieOffset.lon || 0)
							},

							//defaults that are normally overwritten
							sizeFormatter: function () {
								var fn = this.chart.options.customFunctions;
								//pie diameters in px
								var maxPieDiameter = 20;
								//pie Size proportional to absolute value, no categories used
								return fn.pieSize(Math.abs(data.value), fn.getPointsExtremes(pieSizeSeries.points).maxAbsNumber, maxPieDiameter);
							},
							data: [
								//Bubbles: Only one element in the array
								{
									name: pieSizeSeries.name,
									//put absolute value in y, real value in v
									y: Math.abs(data.value),
									v: data.value,
									color: color(data.value),
									borderColor: color(data.value)
								}
							],
							dataLabels: {
								enabled: false
							}
						};
						//create the config handed in from the chart
						var pieTemplate = config(data, correspondingMapSeriesItem, color);
						//merge the two configs (2nd into first, see e.g. https://gist.github.com/TorsteinHonsi/f646f39d51d18b7d6bfb)
						return Highcharts.merge(true, mapPieConfig, pieTemplate);
					};

					// Add the pie for this wohnviertel to the chart
					chart.addSeries(currentPieSeries(pieSeriesConfig), false);

					/*
					// Draw connector to wohnviertel center if the pie has been offset
					if (pieOffset.drawConnector !== false) {
						var centerPoint = chart.fromLatLonToPoint({
								lat: centerLat,
								lon: centerLon
							}),
							offsetPoint = chart.fromLatLonToPoint({
								lat: centerLat + (pieOffset.lat || 0),
								lon: centerLon + (pieOffset.lon || 0)
							});
						pieSizeSeries.addPoint({
							name: wohnviertel.id,
							path: 'M' + offsetPoint.x + ' ' + offsetPoint.y +
								'L' + centerPoint.x + ' ' + centerPoint.y
						}, false);
					}
					*/

				});
				// Only redraw once all pies and connectors have been added
				chart.redraw();
			},
    "addLegendTitle": function (chart, text, x, y, cssClass, useHtml) {
				return chart.renderer.label(text, x, y, undefined, undefined, undefined, useHtml)
					.css({
						fontSize: '15px',
						fontWeight: 'bold'
					})
					.attr({
						zIndex: 6,
						//class: 'pieLegend'
					}).add();
			},
    "addLegendCircle": function (chart, x, y, radius, fill, cssClass) {
				return chart.renderer.circle(x, y, radius, fill).attr({
					fill: fill,
					stroke: fill,
					'stroke-width': 1,
					zIndex: 6,
					class: cssClass + ' pieLegend'
				}).add();
			},
    "addLegendLabel": function (chart, text, x, y, cssClass, useHtml) {
				return chart.renderer.label(text, x, y, undefined, undefined, undefined, useHtml)
					.css({
						fontSize: '15px'
					})
					.attr({
						zIndex: 6,
						class: cssClass + ' pieLegend'
					}).add();
			},
    "addLegendLabelbold": function (chart, text, x, y, cssClass, useHtml) {
				return chart.renderer.label(text, x, y, undefined, undefined, undefined, useHtml).
					attr({
						zIndex: 6,
						class: cssClass + ' pieLegend'
					})
					.css({
						fontWeight: 'bold'
					}).
					add();
			},
    "addLegendSquare": function (chart, x, y, width, fill, cssClass) {
				return chart.renderer.rect(x, y, width, width, 0).attr({
					'stroke-width': 0,
					fill: fill,
					zIndex: 6,
					class: cssClass + ' pieLegend'
				}).add();
			},
    "AddPieLegendClickHandler": function (chart) {
				var divId = chart['renderTo']['id'] || 'dummySettingForExportServer';
				var divIdString = '#' + divId;
				$(divIdString + ' .pieLegend').click(function () {
					//Toggle visible of mappies
					Highcharts.each(chart.series, function (series) {
						if (series.userOptions.type == 'mappie') {
							series.setVisible(!series.visible, false);
						}
					});
					chart.redraw();


					//if useHTMl is true, text is in span elements within DIVs classed .pieLegend. Add the class to these spans
					$(divIdString + ' .pieLegend>span').addClass('pieLegend').addClass('pieLegendHtmlText');
					//toggle active state of legend elements
					var pieLegendItems = $(divIdString + ' .pieLegend');
					//backup original color
					pieLegendItems.each(function (i, v) {
						if (!$(this).attr('fill_active')) {
							//if no fill color is defined, set to  black
							$(this).attr('fill_active', $(this).attr('fill') || 'black');
						}
						if (!$(this).attr('stroke_active')) {
							$(this).attr('stroke_active', $(this).attr('stroke') || null);
						}
					});
					//toggle color
					if (pieLegendItems.attr('fill') == pieLegendItems.attr('fill_active')) {
						//set all to grey
						pieLegendItems.attr('fill', '#cccccc');
						//if stroke is present, toggle it
						pieLegendItems.each(function (i, v) {
							//if stroke_active is present, set it to grey
							if ($(this).attr('stroke_active')) {
								$(this).attr('stroke', '#cccccc');
							}
						});
						//same for html text spans
						$(divIdString + ' .pieLegendHtmlText').css('color', '#cccccc');
					}
					else {
						pieLegendItems.each(function (i, v) {
							//set each to its fill_active color
							$(this).attr('fill', $(this).attr('fill_active'));
							$(this).attr('stroke', $(this).attr('stroke_active'));
						});
						//same for html text spans
						$(divIdString + ' .pieLegendHtmlText').css('color', 'black');
					}
				});
			}
  },
  "plotOptions": {
    "series": {
      "pointWidth": 25,
      "dataLabels": {
        "style": {
          "fontSize": 10
        }
      },
      "stacking": "normal"
    }
  },
  "yAxis": {
    "labels": {
      "format": "{value:,.0f}"
    },
    "reversedStacks": false
  },
  "tooltip": {
    "pointFormat": "\u003Cspan style=\"color:{series.color}\"\u003E●\u003C\u002Fspan\u003E {series.name}: \u003Cb\u003E{point.y}\u003C\u002Fb\u003E\u003Cbr\u002F\u003E",
    "shared": false
  }
}